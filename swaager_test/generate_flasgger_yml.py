# -*- coding: utf-8 -*-
# @Time: 2023/5/22 9:26
# @Author: lijunhui
# @File: generate_flasgger_yml.py
"""
generate_flasgger_yml.py
"""
import json, yaml, logging, copy
import os

from flasgger import swag_from, Swagger


# 根据示例的json数据自动生成yml文件
def generate_yml(json_path, yml_file_name):
    """
    根据示例的json数据自动生成yml文件.

    :param json_path: 示例的json数据文件路径.其中必须包含request和response的json数据，可选择包含tags和summary等信息
    :param yml_file_name: 生成的yml文件名
    """

    # 根据request的json的一个key-value，生成一个property
    def generate_property(key, value):
        """
        根据request的json的一个key-value，生成一个property
        :param key: json的key
        :param value: json的value
        :return: 一个property对应的字典
        """
        property_type = type(value)

        _property = {}
        # 判断value的类型，如果是dict类型或者list类型，需要递归生成properties
        if isinstance(value, dict):
            property_type = "object"
        elif isinstance(value, list):
            property_type = "array"
        else:
            # 判断value的基本类型
            if isinstance(value, str):
                property_type = "string"
            elif isinstance(value, int):
                property_type = "integer"
            elif isinstance(value, float):
                property_type = "number"
            elif isinstance(value, bool):
                property_type = "boolean"
            elif isinstance(value, str):
                property_type = "string"
            else:
                raise TypeError("The type of value is not supported.")

        _property["type"] = property_type
        _property["description"] = "".join(["DEFAULT description: The ", key, " need type of ", property_type])
        _property["default"] = copy.deepcopy(value)  # 深拷贝一份原key-value对的value值，避免yml输出一个地址
        # 递归生成property
        if property_type == "array":
            _property["items"] = generate_property("iterm", value[0])
        elif property_type == "object":
            _property["properties"] = generate_properties(value)
        return _property

    # 根据json生成properties
    def generate_properties(json_data: dict):
        """
        根据json生成properties

        :param json_data: json数据
        :return: properties字典
        """
        properties = {}
        for key, value in json_data.items():
            # 根据request的json的一个key-value，生成一个property
            try:
                _property = generate_property(key, value)
                properties[key] = _property
            except TypeError as e:
                # 无法生成property，说明value的类型不支持，提示警告
                logging.warning("The type of value is not supported, key: %s, value: %s" % (key, value))
        return properties

    # 根据json数据生成schema
    def generate_schema(json_data, is_parameter: bool = True):
        return {"id": "DEFAULT_PARAMETER_SCHEMA_ID" if is_parameter else "DEFAULT_RESPONSE_SCHEMA_ID",
                "required": list(json_data.keys()),
                "properties": generate_properties(json_data),
                }

    # 根据json数据，生成spec字典
    def generate_spec(json_data: dict):
        """
        根据json数据，生成spec字典

        :param json_data: json数据，其中必须包含request和response的json数据，可选择包含tags和summary等信息
        :return: spec字典
        """
        request_json = json_data.get("request", None)
        response_json = json_data.get("response", None)
        if request_json is None or response_json is None:
            raise ValueError("The json data must contain request and response json data.")

        tags = json_data.get("tags", None)
        spec_dict = {
            "tags": tags if tags is not None else ["DEFAULT_TAG"]
        }

        # 1 根据request的json数据生成parameters入参信息
        # 注意：这里的parameters是一个list，因为可能有多个入参，但默认会将所有入参包含到一块，作为一个schema
        parameters = [{"name": "DEFAULT_NAME", "in": "body", "required": True,
                       "schema": generate_schema(request_json), }, ]

        # 2 根据response的json数据生成responses出参信息
        responses = {200: {
            "description": "DEFAULT_DESCRIPTION",
            "schema": generate_schema(response_json, is_parameter=False)
        }}

        # 3 将parameters和responses添加到spec_dict中
        spec_dict["parameters"] = parameters
        spec_dict["responses"] = responses
        return spec_dict

    # 1. 读取json数据，转成dict
    with open(json_path, "r", encoding="utf-8") as f:
        json_data = json.load(f)

    # 生成一个spec字典
    spec_dict = generate_spec(json_data)

    # 2. 生成yml文件
    with open(yml_file_name, "w", encoding="utf-8") as f:
        # 编写yml文件头，作为默认的的方法注释
        f.write("Auto generated by generate_yml.py\n"
                "Change the default description and name of parameters and responses.\n"
                "---\n")
        # 将一个python的spec字典转成yml格式的字符串
        yml_str = yaml.dump(spec_dict, default_flow_style=False, sort_keys=False)
        f.write(yml_str)

    # # 2. 生成json文件
    # with open('test_json.json', "w", encoding="utf-8") as f:
    #     # 将一个python的spec字典转成json格式的字符串
    #     json_str = json.dumps(spec_dict)
    #     f.write(json_str)


# region 根据complex端点，测试json生成yml
# 生成yml文件
generate_yml("complex_test.json", "complex.yml")
# endregion

# region 测试的API端点
from flask import Flask, jsonify, request

app = Flask(__name__)
swag = Swagger(app)


@app.route("/validate_annotation", methods=['POST'])
@swag.validate('User')
@swag_from("test_validation.yml")
def validate_annotation():
    data = request.json
    return jsonify(data)


# 一个输出复杂的json的端点
@app.route('/complex', methods=['POST'])
@swag_from("complex.yml")
def complex_test():
    """
    This is a complex_test example, needs swagger API docs

    请求与响应：{
    "tags": ["complex_test"],
    "request": {"username": "lijunhui", "age": 18},
    "response":
    {
        "age": 18,
        "author": "lijunhui",
        "data": [
            {
                "a": "test1",
                "b": "test2",
                "c": "test3"
            },
            {
                "a": "test4",
                "b": "test5",
                "c": "test6"
            },
            {
                "a": "test7",
                "b": "test8",
                "c": "test9"
            }
        ],
        "name": "lijunhui",
        "version": "1.0.0"
    }}
    """
    data = request.json
    username = data.get('username', None)
    age = data.get('age', None)

    if username is None or age is None:
        return jsonify({'error': 'username or age is None'}, 400)

    # 输出嵌套包含的json
    response = {
        'name': username,
        'age': age,
        'version': '1.0.0',
        'author': 'lijunhui',
        'data': [
            {
                'a': 'test1',
                'b': 'test2',
                'c': 'test3',
            },
            {
                'a': 'test4',
                'b': 'test5',
                'c': 'test6',
            },
            {
                'a': 'test7',
                'b': 'test8',
                'c': 'test9',

            }
        ],
    }
    return jsonify(response)


# 启动
if __name__ == '__main__':
    app.run(debug=True)

# endregion
